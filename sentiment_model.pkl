import pandas as pd
import re
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import Pipeline
from sklearn.metrics import accuracy_score

# Load the dataset
def load_data():
    features_name = ['target', 'ids', 'date', 'flag', 'user', 'text']
    data = pd.read_csv('sentiment140/training.1600000.processed.noemoticon.csv', names=features_name, encoding='ISO-8859-1')
    data = data[['target', 'text']]
    data['target'] = data['target'].apply(lambda x: 1 if x == 4 else 0)  # Convert target to binary (0 = negative, 1 = positive)
    return data

# Clean and preprocess tweets
def preprocess_tweet(text):
    text = re.sub(r'@\w+', '', text)  # Remove mentions
    text = re.sub(r'http\S+', '', text)  # Remove URLs
    text = re.sub(r'[^\w\s]', '', text)  # Remove punctuation
    text = text.lower().strip()  # Convert to lowercase and strip whitespace
    return text

# Train a simple logistic regression model
def train_model(data):
    data['text'] = data['text'].apply(preprocess_tweet)
    X_train, X_test, y_train, y_test = train_test_split(data['text'], data['target'], test_size=0.2, random_state=42)
    pipeline = Pipeline([('vect', CountVectorizer()), ('clf', LogisticRegression(max_iter=1000))])
    model = pipeline.fit(X_train, y_train)
    print(f"Accuracy on test set: {accuracy_score(y_test, model.predict(X_test))}")
    return model

# Predict sentiment with emoji output
def predict_sentiment(model, text):
    processed_text = preprocess_tweet(text)
    prediction = model.predict([processed_text])[0]
    return "ðŸ˜Š" if prediction == 1 else "ðŸ˜ž"
